[
  {
    "language": "java",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514669/beats-100-binary-search-explained-with-video-c-java-python-js/",
        "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int numJobs = profit.length; // Number of jobs\n        Job[] jobs = new Job[numJobs];\n\n        for (int i = 0; i < numJobs; ++i) {\n            jobs[i] = new Job(endTime[i], startTime[i], profit[i]);\n        }\n\n        Arrays.sort(jobs, Comparator.comparingInt(job -> job.endTime));\n        int[] dp = new int[numJobs + 1];\n\n        for (int i = 0; i < numJobs; ++i) {\n            int endTimeValue = jobs[i].endTime;\n            int startTimeValue = jobs[i].startTime;\n            int profitValue = jobs[i].profit;\n\n            int latestNonConflictJobIndex = upperBound(jobs, i, startTimeValue);\n            dp[i + 1] = Math.max(dp[i], dp[latestNonConflictJobIndex] + profitValue);\n        }\n\n        return dp[numJobs];\n    }\n\n    private int upperBound(Job[] jobs, int endIndex, int targetTime) {\n        int low = 0;\n        int high = endIndex;\n\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (jobs[mid].endTime <= targetTime) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    private static class Job {\n        int endTime;\n        int startTime;\n        int profit;\n\n        public Job(int endTime, int startTime, int profit) {\n            this.endTime = endTime;\n            this.startTime = startTime;\n            this.profit = profit;\n        }\n    }\n}\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514772/beats-98-java-treemap-binarysearch-c-detailed-explanation/",
        "code": "class Solution {\n        private class Job {\n        private int startTime;\n        private int endTime;\n        private int profit;\n\n        Job(int startTime, int endTime, int profit) {\n            this.startTime = startTime;\n            this.endTime = endTime;\n            this.profit = profit;\n        }\n    }\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        List<Job> jobs = new ArrayList<>();\n        for(int i=0; i<startTime.length; i++) {\n            jobs.add(new Job(startTime[i], endTime[i], profit[i]));\n        }\n\n        Collections.sort(jobs, (a,b) -> a.endTime - b.endTime);\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        int ans = 0;\n\n        for(Job currJob : jobs) {\n            Integer entryTillStartTime = map.floorKey(currJob.startTime);\n            int maxProfitStartTime = entryTillStartTime==null ? 0 : map.get(entryTillStartTime);\n            ans = Math.max(ans, maxProfitStartTime + currJob.profit);\n            map.put(currJob.endTime, ans);\n        }\n        return ans;\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516365/c-solution-for-maximum-profit-in-job-scheduling-problem/",
        "code": "public class Solution {\n    public int JobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.Length;\n        List<Job> jobs = new List<Job>();\n        \n        for (int i = 0; i < n; i++) {\n            jobs.Add(new Job(startTime[i], endTime[i], profit[i]));\n        }\n        \n        jobs.Sort((x, y) => x.EndTime.CompareTo(y.EndTime));\n        \n        int[] dp = new int[n + 1];\n        \n        for (int i = 1; i <= n; i++) {\n            dp[i] = Math.Max(dp[i - 1], jobs[i - 1].Profit);\n            for (int j = i - 1; j > 0; j--) {\n                if (jobs[i - 1].StartTime >= jobs[j - 1].EndTime) {\n                    dp[i] = Math.Max(dp[i], dp[j] + jobs[i - 1].Profit);\n                    break;\n                }\n            }\n        }\n        \n        return dp[n];\n    }\n}public class Job {\n    public int StartTime;\n    public int EndTime;\n    public int Profit;\n    \n    public Job(int start, int end, int prof) {\n        StartTime = start;\n        EndTime = end;\n        Profit = prof;\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517073/so-simple-so-elegant-just-looking-like-a-wow-solution-binary-search-with-dp/",
        "code": "class jobState{\n    public:\n        int start;\n        int end;\n        int profit;\n};\n\nint dp[60006];\nclass Solution {\nprivate:\n    static bool mycmp(jobState &j1 , jobState &j2){\n        return j1.start <= j2.start;\n    }\n\n    int getNextIndex(vector<jobState>&info,int currEnd){\n        int index = -1;\n        int start = -1,end = info.size();\n        while(end - start > 1){\n            int mid = start + (end-start)/2;\n            if(info[mid].start >= currEnd){\n                index = mid;\n                end = mid;\n            }\n            else{\n                start = mid;\n            }\n        }\n        return index;\n    }\n    int f(int idx, vector<jobState>&info){\n        if(idx >= info.size()){\n            return 0;\n        }\n        if(dp[idx]!=-1) return dp[idx];\n        int currEnd = info[idx].end;\n        int nextIdx = getNextIndex(info,currEnd);\n        int take = info[idx].profit + f(nextIdx,info);\n        int notTake = f(idx+1,info);\n        return dp[idx] = max(take,notTake);\n    }\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        memset(dp,-1,sizeof(dp));\n        int n = startTime.size();\n        vector<jobState>vp(n);\n        for(int i = 0 ; i < n ; i++){\n            vp[i].start = startTime[i];\n            vp[i].end = endTime[i];\n            vp[i].profit = profit[i];\n        }\n        sort(vp.begin(),vp.end(),mycmp);\n        int ans = f(0,vp);\n        return ans;\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516554/o-nlogn-no-dp-no-binary-search-heaps-of-fun/",
        "code": "class Solution {\n    // a novel method for solving this partiular problem. does it in O(nlogn) time, O(N) space.\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        // create easier-to-sort 2d array holding all jobs. O(N) time, O(N) space where N is the number of jobs.\n        int[][] jobs = new int[startTime.length][];\n        for (int i = 0; i < jobs.length; i++) {\n            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        // sort the array depending on the start times in ascending order. O(nlogn) time.\n        Arrays.sort(jobs, (a, b) -> a[0] - b[0]);\n        // create a priority queue which holds possible later-bests (time-profit pairs which denote a possible profit available at a time)\n        PriorityQueue<int[]> laterBests = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        // the best profit available before or at the current time. (starts at 0, continues with curTime)\n        int max = 0;\n        for (int[] job : jobs) {\n            // iterates through all jobs. sets the curTime to the start time of the current job.\n            int curTime = job[0];\n            while (!laterBests.isEmpty()) {\n                // resolves the invariant. updates max to be equal to the best of all time-profit pairs in laterBests which have a time less than or equal to curTime.\n                int[] possible = laterBests.poll();\n                if (possible[0] > curTime) {\n                    // breaks when a time too large is found.\n                    laterBests.offer(possible);\n                    break;\n                }\n                if (possible[1] > max) max = possible[1];\n            }\n            // adds a new entry, with the time endTime (of the current job) and a profit equal to the max thus far added to the profit of the current job.\n            laterBests.add(new int[]{job[1], max + job[2]});\n        }\n        // cleans up the priority queue by mopping up any better profits available at times later than the latest job start time. these, too, are available.\n        while (!laterBests.isEmpty()) {\n            int[] possible = laterBests.poll();\n            if (possible[1] > max) max = possible[1];\n        }\n        // returns the maximum time.\n        return max;\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4519267/best-and-easy-solution-using-binary-search-and-bottom-up-approach/",
        "code": "class Solution {\n    private int binarySearch(int[][] jobs, int end, int left, int right) {\n        int result = -1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (jobs[mid][1] <= end) {\n                result = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        int[][] jobs = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            jobs[i][0] = startTime[i];\n            jobs[i][1] = endTime[i];\n            jobs[i][2] = profit[i];\n        }\n\n        Arrays.sort(jobs, Comparator.comparingInt(m -> m[1]));\n\n        int[] dp = new int[n];\n        dp[0] = jobs[0][2];\n\n        for (int i = 1; i < n; i++) {\n            int prev = 0;\n            int lastJobIndex = binarySearch(jobs, jobs[i][0], 0, i - 1);\n\n            if (lastJobIndex != -1) {\n                prev = dp[lastJobIndex];\n            }\n\n            dp[i] = Math.max(prev + jobs[i][2], dp[i - 1]);\n        }\n\n        return dp[n - 1];\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517771/solution-with-less-code-and-is-self-explanatory/",
        "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int len = startTime.length;\n        int[][] dp = new int[len][3];\n        for(int i=0; i<len; i++) {\n            dp[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        Arrays.sort(dp, (a,b) -> a[1]-b[1]);\n        TreeMap<Integer, Integer> intsMap = new TreeMap<>();\n        intsMap.put(0,0);\n        for(var i : dp) {\n            int cur = intsMap.floorEntry(i[0]).getValue() + i[2];\n            if(cur > intsMap.lastEntry().getValue()) {\n                intsMap.put(i[1], cur);\n            }\n        }\n        return intsMap.lastEntry().getValue();\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517109/c-sorting-dynamic-programming-binary-search-clean-code/",
        "code": "public class Solution {\n    private Meeting[] _meetings;\n    private int[] _memoization;\n    \n    private const int EmptyState = -1;\n    \n    public int JobScheduling(int[] startTime, int[] endTime, int[] profit)\n    {\n        Initialization(startTime, endTime, profit);\n        return FindMaxProfit(0);\n    }\n\n    private int FindMaxProfit(int index)\n    {\n        if (index >= _meetings.Length)\n        {\n            return 0;\n        }\n\n        if (_memoization[index] != EmptyState)\n        {\n            return _memoization[index];\n        }\n\n        var nextMeetingIndex = FindNextAvailableMeeting(index + 1, _meetings[index].EndTime);\n\n        var skip = FindMaxProfit(index + 1);\n        var schedule = _meetings[index].Profit + FindMaxProfit(nextMeetingIndex);\n        \n        return _memoization[index] = Math.Max(skip, schedule);\n    }\n    \n    int FindNextAvailableMeeting(int currentIndex, int nextStartTime)\n    {\n        var start = currentIndex;\n        var end = _meetings.Length - 1; \n        var nextAvailableMeetingIndex = _meetings.Length;\n\n        while (start <= end)\n        {\n            var mid = (start + end) / 2;\n            if (_meetings[mid].StartTime >= nextStartTime)\n            {\n                nextAvailableMeetingIndex = mid;\n                end = mid - 1;\n            }\n            else\n            {\n                start = mid + 1;\n            }\n        }\n\n        return nextAvailableMeetingIndex;\n    }\n\n    void Initialization(int[] startTime, int[] endTime, int[] profit)\n    {\n        _meetings = new Meeting[startTime.Length];\n        _memoization = new int[startTime.Length + 1];\n        \n        for (int i = 0; i < startTime.Length; i++)\n        {\n            _meetings[i] = new Meeting(startTime[i], endTime[i], profit[i]);\n        }\n\n        Array.Fill(_memoization, EmptyState);\n        Array.Sort(_meetings);\n    }\n\n    record Meeting(int StartTime, int EndTime, int Profit) : IComparable<Meeting>\n    {\n        public int CompareTo(Meeting? other)\n        {\n            return StartTime.CompareTo(other.StartTime);\n        }\n    }\n}\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516345/java-solution-for-maximum-profit-in-job-scheduling-problem/",
        "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        int[][] jobs = new int[n][3];\n        \n        for (int i = 0; i < n; i++) {\n            jobs[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n        \n        Arrays.sort(jobs, Comparator.comparingInt(a -> a[1]));\n        \n        TreeMap<Integer, Integer> dp = new TreeMap<>();\n        dp.put(0, 0);\n        \n        for (int[] job : jobs) {\n            int prevProfit = dp.floorEntry(job[0]).getValue();\n            int maxProfit = prevProfit + job[2];\n            \n            if (maxProfit > dp.lastEntry().getValue()) {\n                dp.put(job[1], maxProfit);\n            }\n        }\n        \n        return dp.lastEntry().getValue();\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515967/java-solution-beats-86-dp-binary-search-sorting/",
        "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n=startTime.length;\n        Job jobs[]=new Job[n];\n        for(int i=0; i<n; i++) {\n            jobs[i]=new Job(startTime[i], endTime[i], profit[i]);\n        }\n        Arrays.sort(jobs, (j1, j2)->{\n            if(j1.start!=j2.start) { // sort by startTime first\n                return j1.start-j2.start;\n            }else if(j1.end!=j2.end) { // then by end time\n                return j1.end-j2.end;\n            }else { //then by profit\n                return j2.profit-j1.profit;\n            }\n        });\n        dp=new Integer[n];\n        return util(jobs, 0);\n    }\n\n    private Integer dp[];\n\n    private int util(Job jobs[], int i) {\n        if(i==jobs.length) {\n            return 0;\n        }\n\n        if(dp[i]!=null) return dp[i];\n\n        int ret=0;\n        //schedule this jobs[i]\n        //binary search\n        int l=i;\n        int h=jobs.length;\n        while(l+1<h) {\n            int mid=(l+h)/2;\n            if(jobs[mid].start>=jobs[i].end) {\n                h=mid;\n            }else {\n                l=mid;\n            }\n        }\n        ret=Math.max(ret, jobs[i].profit+util(jobs, h));\n        //don't schedule\n        ret=Math.max(ret, util(jobs, i+1));\n        return dp[i]=ret;\n    }\n\n    private class Job {\n        public int start;\n        public int end;\n        public int profit;\n        public Job(int s, int e, int p) {\n            this.start=s;\n            this.end=e;\n            this.profit=p;\n        }\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515426/solution-for-problem-of-the-day/",
        "code": "class Job {\n  public int startTime;\n  public int endTime;\n  public int profit;\n  public Job(int startTime, int endTime, int profit) {\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.profit = profit;\n  }\n}\n\nclass Solution {\n  public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n    final int n = startTime.length;\n    dp = new int[n + 1];\n    Job[] jobs = new Job[n];\n\n    for (int i = 0; i < n; ++i)\n      jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n\n    Arrays.sort(jobs, (a, b) -> a.startTime - b.startTime);\n    for (int i = 0; i < n; ++i)\n      startTime[i] = jobs[i].startTime;\n\n    return jobScheduling(jobs, startTime, 0);\n  }\n\n  private int[] dp;\n\n  private int jobScheduling(Job[] jobs, int[] startTime, int i) {\n    if (i == jobs.length)\n      return 0;\n    if (dp[i] > 0)\n      return dp[i];\n\n    final int j = firstGreaterEqual(startTime, i + 1, jobs[i].endTime);\n    final int pick = jobs[i].profit + jobScheduling(jobs, startTime, j);\n    final int skip = jobScheduling(jobs, startTime, i + 1);\n    return dp[i] = Math.max(pick, skip);\n  }\n\n  private int firstGreaterEqual(int[] A, int startFrom, int target) {\n    int l = startFrom;\n    int r = A.length;\n    while (l < r) {\n      final int m = (l + r) / 2;\n      if (A[m] >= target)\n        r = m;\n      else\n        l = m + 1;\n    }\n    return l;\n  }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4518530/optimized-dynamic-programming-with-binary-search-for-job-scheduling/",
        "code": "class Solution {\n    private record Jobs(int startTime,int endTime, int profit){}\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n\n        int noOfJobs = startTime.length;\n        var jobs = new Jobs[noOfJobs];\n\n        for(int i=0; i < noOfJobs; i++){\n            jobs[i] = new Jobs(startTime[i], endTime[i], profit[i]);\n        }\n\n        Arrays.sort(jobs, Comparator.comparingInt(job-> job.endTime));\n        var dp = new int[noOfJobs+1];\n\n        for(int i= 0 ; i < noOfJobs ;i++ ){\n            \n            int prevJob = getPreviousNonOverLappingJob(jobs,i,jobs[i].startTime);\n            dp[i+1] = Math.max(dp[i], dp[prevJob] + jobs[i].profit );\n        }\n        \n        return dp[noOfJobs];\n    }\n\n    private static int getPreviousNonOverLappingJob(Jobs[] jobs,int endIndex, int targetTime){\n        int low = 0;\n        int high = endIndex;\n\n        while(low < high){\n            int mid = (low + high)/2;\n            if(jobs[mid].endTime <= targetTime){\n                low = mid + 1;\n            }else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515594/combine-intervals-binary-search-and-lis-to-make-a-cool-solution-beats-95/",
        "code": "class Solution {\n    class Job implements Comparable<Job> {\n        int start;\n        int end;\n        int profit;\n\n        public Job(int s, int e, int p){\n            this.start = s;\n            this.end = e;\n            this.profit = p;\n        }\n\n        @Override\n        public int compareTo(Job o) {\n            if (this.start == o.start){\n                return Integer.compare(this.end, o.end);\n            }\n            return Integer.compare(this.start, o.start);\n        }\n        \n    }\n\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        Job[] jobs = new Job[n];\n        \n        for (int i = 0; i < n; i++) {\n            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n        }\n\n        Arrays.sort(jobs);\n         \n        int[] dp = new int[n];\n        dp[n - 1] = jobs[n - 1].profit;\n\n        for (int start = n - 2; start >= 0; start--) {\n            int currentProfit = jobs[start].profit;\n            int nextJob = binarySearch(jobs, start);\n\n            if (nextJob != -1) {\n                currentProfit += dp[nextJob];\n            }\n\n            dp[start] = Math.max(curr, dp[start + 1]);\n            \n        }\n\n        return dp[0];\n    }\n\n    private int binarySearch(Job[] jobs, int index) {\n        int start = index + 1;\n        int end = jobs.length - 1;\n        int ans = -1;\n\n        while (start <= end) {\n            int mid = start + (end - start)/2;\n             if(jobs[mid].start >= jobs[index].end){\n                 ans = mid;\n                 end = mid - 1;\n             } else{\n                 start = mid + 1;\n             }\n        }\n        return ans;\n    }\n\n    public int tooSlow(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        Job[] jobs = new Job[n];\n        \n        for (int i = 0; i < n; i++) {\n            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n        }\n\n        Arrays.sort(jobs);\n         \n        int[] dp = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = jobs[i].profit;\n        }\n        int max = dp[n - 1];\n\n        for (int start = n - 2; start >= 0; start--) {\n            for (int end = start + 1; end < n; end++) {\n                if (jobs[start].end <= jobs[end].start) {\n                    dp[start] = Math.max(dp[start], jobs[start].profit + dp[end]);\n                }\n            }\n            max = Math.max(dp[start], max);\n        }\n\n        return max;\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515017/i-feel-sick-today-java-100-solution/",
        "code": "import java.util.Arrays;\nimport java.util.TreeMap;\n\nclass Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        \n        // Create an array to store jobs\n        Job[] jobs = new Job[n];\n        for (int i = 0; i < n; i++) {\n            jobs[i] = new Job(startTime[i], endTime[i], profit[i]);\n        }\n        \n        // Sort jobs based on end time\n        Arrays.sort(jobs, (a, b) -> Integer.compare(a.end, b.end));\n        \n        // TreeMap to store maximum profit at each time point\n        TreeMap<Integer, Integer> dp = new TreeMap<>();\n        dp.put(0, 0); // Initial profit is 0\n        \n        for (Job job : jobs) {\n            // Find the closest previous job that doesn't overlap\n            Integer prevJobEnd = dp.floorKey(job.start);\n            \n            // Calculate the new profit if we include the current job\n            int newProfit = dp.get(prevJobEnd) + job.profit;\n            \n            // Update the maximum profit at the current time\n            int maxProfit = Math.max(newProfit, dp.lastEntry().getValue());\n            dp.put(job.end, maxProfit);\n        }\n        \n        return dp.lastEntry().getValue();\n    }\n}\n\nclass Job {\n    int start;\n    int end;\n    int profit;\n\n    public Job(int start, int end, int profit) {\n        this.start = start;\n        this.end = end;\n        this.profit = profit;\n    }\n}\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515749/east-to-understand-dp-greedy/",
        "code": "class Solution {\n    private int findLatestNonOverlap(int[][] jobs, int currentJob) {\n        for (int i = currentJob - 1; i >= 0; i--) {\n            if (jobs[i][1] <= jobs[currentJob][0]) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        int[][] jobs = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            jobs[i][0] = startTime[i];\n            jobs[i][1] = endTime[i];\n            jobs[i][2] = profit[i];\n        }\n\n        Arrays.sort(jobs, Comparator.comparingInt(o -> o[1]));\n\n        int[] dp = new int[n];\n        dp[0] = jobs[0][2];\n\n        for (int i = 1; i < n; i++) {\n            int currentProfit = jobs[i][2];\n            int latestNonOverlap = findLatestNonOverlap(jobs, i);\n\n            if (latestNonOverlap != -1) {\n                currentProfit += dp[latestNonOverlap];\n            }\n\n            dp[i] = Math.max(currentProfit, dp[i - 1]);\n        }\n\n        return dp[n - 1];\n    }\n}"
      }
    ]
  },
  {
    "language": "cpp",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514794/beats-100-users-c-java-python-javascript-with-explanation/",
        "code": "class Solution {\npublic:\n\n    int jobScheduling(vector<int>& s, vector<int>& e, vector<int>& p) {\n       \n        int n = s.size(); \n        vector<pair<int, int>> st(n);\n        for(int i = 0; i < n; i++) st[i] = {s[i], i};\n        sort(st.begin(), st.end());\n        vector<int> dp(n+1, 0); \n        for(int i = n-1; i > -1; i--)\n            dp[i] += max(dp[i+1], p[st[i].second] + dp[lower_bound(st.begin() + i, st.end(), make_pair(e[st[i].second], 0)) - st.begin()]);\n        return dp[0];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517098/easy-solution/",
        "code": "class Solution {\npublic:\n    int rec( int idx , vector<vector<int>>&jobs , vector<int>&startTime , vector<int>&dp)\n    {\n        if( idx >= startTime.size())\n        {\n            return 0;\n        }\n\n        if(dp[idx] != -1)\n        {\n            return dp[idx];\n        }\n\n        int nextIndex = lower_bound(startTime.begin() , startTime.end() , jobs[idx][1])-startTime.begin();\n\n        int take = jobs[idx][2] + rec( nextIndex , jobs , startTime , dp);\n\n        int notTake = rec( idx + 1 , jobs , startTime , dp);\n\n        return dp[idx] = max( take , notTake);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n         \n         vector<vector<int>>jobs;\n         \n         int n = startTime.size();\n\n         vector<int>dp( n , -1);\n\n         for( int i = 0 ; i < startTime.size() ; i++)\n         {\n             jobs.push_back({ startTime[i] , endTime[i] , profit[i]});\n         }\n\n         sort(jobs.begin() , jobs.end());\n\n         sort(startTime.begin() , startTime.end());\n\n         return rec( 0 , jobs , startTime , dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515659/c-dynamic-programming-with-binary-search-hash-map/",
        "code": "class Solution {\npublic:\n    // time/space: O(nlogn)/O(n)\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        // sort the job {end, start, profit} by the end time\n        const int n = startTime.size();\n        vector<vector<int>> jobs(n);\n        for (int i = 0; i < n; i++) jobs[i] = {endTime[i], startTime[i], profit[i]};\n        sort(jobs.begin(), jobs.end());\n\n        // dynamic programming {end, profit}\n        map<int, int> dp = {{0, 0}};\n        for (auto& job : jobs) {\n            // take the current job based on the right-most non-overlapping job\n            // the end time of the selected job must be smaller or equal to the start time of the current job\n            // so we can use `prev(upper_bound())` to meet the condition `currStart >= prevEnd`\n            int profit = prev(dp.upper_bound(job[1]))->second + job[2];\n            // append the element if it's best so far\n            if (profit > dp.rbegin()->second) dp[job[0]] = profit;\n        }\n        return dp.rbegin()->second;\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514706/beats-100-users-c-java-python-javascript-dp-explained/",
        "code": "class Solution {\npublic:\n\n    int find(int i, vector<vector<int>>&job, vector<int>&startTime, int n,vector<int>&dp){\n        if(i>=n)return 0;\n        if(dp[i]!=-1)return dp[i];\n        \n        int index = lower_bound(startTime.begin(),startTime.end(),job[i][1])-startTime.begin();\n        int pick = job[i][2] + find(index,job,startTime,n,dp);\n        int notpick = find(i+1,job,startTime,n,dp);\n        return dp[i] = max(pick,notpick);\n\n    }\n\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        \n        int n = startTime.size();\n        vector<vector<int>>job;\n        vector<int>dp(n,-1);\n        for(int i =0;i<n;i++){\n            job.push_back({startTime[i],endTime[i],profit[i]});\n        }\n        sort(job.begin(),job.end());\n        sort(startTime.begin(),startTime.end());\n        return find(0,job,startTime,n,dp);\n        }\n};\n\n\n\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515648/january6-24-pod-c-dp-full-explanation-beats-100/",
        "code": "class Solution {\npublic:\n    int numJobs;\n    int memo[50001];\n\n\n    int getNextIndex(vector<vector<int>>&jobs , int l , int end){\n        int r = numJobs - 1;\n        int res = numJobs;\n        while(l <= r){\n            int mid = l + ((r-l) >> 1);\n\n            if(jobs[mid][0] >= end){\n                res = mid;\n                r = mid - 1;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return res;\n    }\n    int solve(vector<vector<int>>&jobs ,vector<int>&startTime , int i){\n\n        if(i >= numJobs){\n            return 0;\n        }\n\n\n        //if we have already calculated the max profit of that job\n        if(memo[i] != -1){\n            return memo[i];\n        }\n\n        //include\n        int next = getNextIndex(jobs , i+1 , jobs[i][1]);\n        //we are using binary search here to get the next index\n        //it helps us to find the lower bound of the next safe job to take\n        //so passing jobs , start , end\n\n        //instead we can also use lower_bound function directly but it is always better to write your own function\n\n        // int next = lower_bound(startTime.begin() , startTime.end() , jobs[i][1]) - startTime.begin();\n\n        int inc = jobs[i][2] + solve(jobs , startTime , next);\n\n\n        //not include\n        int not_inc = solve(jobs , startTime, i + 1);\n\n        return memo[i] = max(inc , not_inc);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        numJobs = startTime.size();\n        memset(memo , -1 , sizeof(memo));\n        \n        vector<vector<int>>jobs(numJobs , vector<int>(3,0));\n        for(int i = 0 ; i < numJobs ; i++){\n            jobs[i][0] = startTime[i];\n            jobs[i][1] = endTime[i];\n            jobs[i][2] = profit[i];\n        }\n\n        //we can also create jobs in a diff way\n        // vector<tuple<int,int,int>>jobs(numJobs);\n\n        // for(int i = 0 ; i < numJobs ;i++){\n        //     jobs[i] = {startTime[i] , endTime[i] , profit[i]};\n        // }\n\n        //by default -> sorted on the basis of first value but still writing comp for better undertsanding\n        auto comp = [&](auto& vec1 , auto& vec2){\n            return vec1[0] <= vec2[0];\n        };\n\n        //sort it on the basis of start time\n        sort(jobs.begin() , jobs.end() , comp);\n\n        return solve(jobs , startTime ,0);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514838/very-easy-approach-fully-explanation-beat-75-users-in-c-dp-using-binary-search/",
        "code": "class Solution {\npublic:\n    int solve(int i, vector<int>& startTime, vector<int>& endTime, vector<int>& profit, vector<int> &dp){\n        if(i == startTime.size()) return 0;\n        if(dp[i] != -1) return dp[i];\n\n        int ind = lower_bound(startTime.begin(), startTime.end(), endTime[i]) - startTime.begin();\n        int take = profit[i] + solve(ind, startTime, endTime, profit, dp);\n        int notTake = solve(i+1, startTime, endTime, profit, dp);\n\n        return dp[i] = max(take, notTake);\n    }\n\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n\n        set<pair<int, pair<int, int>>> st;\n        for(int i=0; i<startTime.size(); i++){\n            st.insert({startTime[i], {endTime[i], profit[i]}});\n        }\n\n        int i = 0;\n        for(auto it: st){\n            pair<int, pair<int, int>> p = it;\n            startTime[i] = p.first;\n            endTime[i] = p.second.first;\n            profit[i] = p.second.second;\n\n            i = i + 1;\n        }\n\n\n        vector<int> dp(n+1, -1);\n        return solve(0, startTime, endTime, profit, dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515229/optimized-job-scheduling-a-dynamic-programming-approach/",
        "code": "class Solution {\npublic:\n   int binarySearch(vector<pair<int, pair<int, int>>>& jobs, int index) {\n    int low = 0, high = index - 1;\n\n    while (low <= high) {\n        int mid = (low + high) / 2;\n\n        if (jobs[mid].first <= jobs[index].second.first) {\n            if (jobs[mid + 1].first <= jobs[index].second.first) {\n                low = mid + 1;\n            } else {\n                return mid;\n            }\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    return -1;\n}\n\nint jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n    int n = startTime.size();\n    vector<pair<int, pair<int, int>>> jobs;\n\n    for (int i = 0; i < n; i++) {\n        jobs.push_back({endTime[i], {startTime[i], profit[i]}});\n    }\n\n    // Sort jobs based on their end times\n    sort(jobs.begin(), jobs.end());\n\n    // dp[i] represents the maximum profit we can get up to the ith job\n    vector<int> dp(n, 0);\n    dp[0] = jobs[0].second.second;\n\n    for (int i = 1; i < n; i++) {\n        int currentProfit = jobs[i].second.second;\n\n        // Find the latest job that finishes before the current job starts using binary search\n        int prevCompatibleJobIndex = binarySearch(jobs, i);\n\n        if (prevCompatibleJobIndex != -1) {\n            currentProfit += dp[prevCompatibleJobIndex];\n        }\n\n        // Update the maximum profit up to the current job\n        dp[i] = max(dp[i - 1], currentProfit);\n    }\n\n    return dp[n - 1];\n}\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515181/simple-java-solution/",
        "code": "class Solution {\n    public int Solve(int arr[][],int index,int dp[])\n    {\n        if(index==arr.length)\n        {\n            return 0;\n        }\n        // 1st case take the value\n        if(dp[index]!=0)\n        {\n            return dp[index];\n        }\n        int end=arr[index][1];\n        int low=0,high=arr.length-1,i=0;\n        while(low<=high)\n        {\n            int mid=(low+high)/2;\n            if(arr[mid][0]>=end)\n            {\n                i=mid;\n                high=mid-1;\n            }\n            else\n            {\n                i=mid+1;\n                low=mid+1;\n            }\n        }\n        \n        int op1=arr[index][2]+Solve(arr,i,dp);\n        // 2nd case, don't take the value\n        int op2=0+Solve(arr,index+1,dp);\n\n        return dp[index]=Math.max(op1,op2);\n    }\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int dp[]=new int[startTime.length];\n        int arr[][]=new int[startTime.length][3];\n        for(int i=0;i<arr.length;i++)\n        {\n            arr[i][0]=startTime[i];\n            arr[i][1]=endTime[i];\n            arr[i][2]=profit[i];\n        }\n\n        Arrays.sort(arr,(a,b)->a[0]-b[0]);\n        return Solve(arr,0,dp);\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4518084/c-easy-to-understand-recursive-to-dp-step-by-step-also-include-lis-approach-clean-code/",
        "code": "// class Solution {\n// public:\n//     int nextIndex(int idx,vector<vector<int>>&a)\n//     {\n//         int end = a.size(),st=idx+1;\n//         while(st<end) {\n//             int md = st+(end-st)/2;\n//             if(a[md][0]>=a[idx][1])\n//             end = md;\n//             else\n//             st=md+1;\n//         }\n//         return st;\n//     }\n//     int f(int idx,vector<vector<int>>&a,vector<int>&dp) {\n//         if(idx==a.size())\n//             return 0;\n//         if(dp[idx]!=-1)\n//             return dp[idx];\n//         int take = a[idx][2] + f(nextIndex(idx,a),a,dp),notTake = f(idx+1,a,dp);\n//         return dp[idx] = max(take,notTake);\n//     }\n//     int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n//         vector<vector<int>>a;\n//         int n = startTime.size();\n//         vector<int>dp(n+1,-1);\n//         for(int i=0;i<n;i++)\n//         a.push_back({startTime[i],endTime[i],profit[i]});\n//         sort(a.begin(),a.end());\n//         return f(0,a,dp);\n//     }\n// };\nclass Solution {\npublic:\n\n    int jobScheduling(vector<int>& s, vector<int>& e, vector<int>& p) {\n        ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n        int n = s.size(); \n        vector<pair<int, int>> st(n);\n        for(int i = 0; i < n; i++) st[i] = {s[i], i};\n        sort(st.begin(), st.end());\n        vector<int> dp(n+1, 0); \n        for(int i = n-1; i > -1; i--)\n            dp[i] += max(dp[i+1], p[st[i].second] + dp[lower_bound(st.begin() + i, st.end(), make_pair(e[st[i].second], 0)) - st.begin()]);\n        return dp[0];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515649/liner-dp-easiest-solution-beginner-friendly-beats-100-binary-search-dp-sort-approaches/",
        "code": "class Solution {\npublic:\nint n;\nint t[50001];\n     int findNextIdx(vector<vector<int>>&arr, int l,int target){\n         int r=n-1;\n         int ans=n+1;\n         while(l<=r){\n             int mid=l+(r-l)/2;\n             if(arr[mid][0]>=target){\n                 ans=mid;\n                 r=mid-1;\n             }\n             else{\n               l=mid+1;\n             }\n         }\nreturn ans;\n     }\n    int solve(vector<vector<int>>&arr,int idx){\n        if(idx>=n)return 0;\n        if(t[idx]!=-1)return t[idx];\n        int next=findNextIdx(arr,idx+1,arr[idx][1]);\n        int taken=arr[idx][2]+solve(arr,next);\n        int not_taken=solve(arr,idx+1);\n        return t[idx]= max(taken,not_taken);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n       n=startTime.size();\n       vector<vector<int>>arr(n,vector<int>(3,0));\n       for(int i=0;i<n;i++){\n           arr[i][0]=startTime[i];\n           arr[i][1]=endTime[i];\n           arr[i][2]=profit[i];\n       }\n       sort(arr.begin(),arr.end());\n       memset(t,-1,sizeof(t));\n       return solve(arr,0);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514872/2-solution-bruteforce-and-dp-binarysearch-clean/",
        "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<tuple<int, int, int>> jobs;\n        for (int i = 0; i < n; ++i) {\n            jobs.push_back({endTime[i], startTime[i], profit[i]});\n        }\n        sort(jobs.begin(), jobs.end());\n\n        int ans = INT_MIN;\n        for (int i = 0; i < n; ++i) {\n            int currProfit = get<2>(jobs[i]);\n            for (int j = 0; j < i; ++j) {\n                if (get<0>(jobs[j]) <= get<1>(jobs[i])) { // if job j ends before or at the same time job i starts\n                    currProfit = max(currProfit, get<2>(jobs[j]) + get<2>(jobs[i]));\n                }\n            }\n            ans = max(ans, currProfit);\n            get<2>(jobs[i]) = currProfit; // update the maximum profit after scheduling job i\n        }\n        return ans;\n    }\n};\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516679/easy-c-solution-dp-elaborate-explanation-with-intuition/",
        "code": "class Solution {\npublic:\n    bool static comp(pair<pair<int, int>, int>& a, pair<pair<int, int>, int>& b) {  \n        return a.first.second < b.first.second;  \n    } \n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        vector<pair<pair<int, int>, int>> vec;\n        int n = startTime.size();\n        for(int i=0; i<n; i++){\n            vec.push_back({{startTime[i], endTime[i]}, profit[i]});\n        }\n        sort(vec.begin(), vec.end(), comp);\n        map<int, int> dp;\n        dp.insert({0,0});\n        for(int i=0; i<n; i++){\n            int end = vec[i].first.second;\n            int start = vec[i].first.first;\n            int prof = vec[i].second;\n            auto prevJobEnd = dp.lower_bound(start);\n            int prevjobend = prevJobEnd->first;\n            if(prevjobend > start)\n                --prevJobEnd;\n            else if(prevjobend < start)\n                prevJobEnd++;\n\n            int newProfit = prevJobEnd->second + prof;\n            int maxProfit = max(newProfit, dp.rbegin()->second);  \n            dp[end] = maxProfit; \n        \n        }\n        return dp.rbegin()->second;\n        \n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4518174/easy-binary-search-dp-solution-c/",
        "code": "class Solution {\npublic:\n    int getIdx(vector<vector<int>>& jobs,int endTime){\n        int n = jobs.size();\n        int l = 0,r = n-1;\n        int ans = n;\n        while(l<=r){\n            int mid = l+(r-l)/2;\n            if(jobs[mid][0]>=endTime){\n                ans = mid;\n                r=mid-1;\n            }\n            else{\n                l=mid+1;\n            }\n        }\n        return ans;\n    }\n\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<vector<int>> jobs;\n        for(int i=0;i<n;i++){\n            jobs.push_back({startTime[i],endTime[i],profit[i]});\n        }\n        sort(jobs.begin(),jobs.end());\n        vector<int> dp(n+1,0);\n        for(int i=n-1;i>=0;i--){\n             int notInclude = dp[i+1];\n             int j = getIdx(jobs,jobs[i][1]);\n             cout<<i<<\" \"<<j<<endl;\n             int include = jobs[i][2]+dp[j];\n             dp[i] = max(include,notInclude);\n        }\n        return dp[0];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4547364/simple-detailed-explanation-comments-memoisation-binary-search/",
        "code": "class Solution {\nprivate:\n    int getNextIndex(vector<vector<int>> &jobs, int l, int currEnd){\n        int n = jobs.size();\n        int r = n-1;\n\n        int res = n+1;\n\n        while(l <= r){\n            int mid = l + (r - l) / 2;\n\n            if(jobs[mid][0] >= currEnd){\n                res = mid;\n                r = mid - 1;\n            }\n            else{\n                l = mid + 1;\n            }\n        }\n        return res;\n    }\n    int f(int i, vector<vector<int>> &jobs, int n, vector<int> &dp){\n        // base case in case of out of bound of the vector\n        if(i >= n) return 0;\n        // DP Check\n        if(dp[i] != -1) return dp[i];\n        // This is a crucial Time saving step, because here we are concerned, to get the next valid index where the startTime is more or equal to the end time of the curr Index, this can be done using linear search but is better to do by Binary Search(lon(N))\n        int next_index = getNextIndex(jobs, i+1, jobs[i][1]);\n\n        // Make the two recursive calls for taken and not taken\n        int notTaken = 0 + f(i+1, jobs, n, dp);\n        int Taken = jobs[i][2] + f(next_index, jobs, n, dp);\n\n        // Store in the DP array and returun the answer\n        return dp[i] = max(Taken, notTaken);\n    }\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        // This Solution is being implemented using the binary Search\n        int n = startTime.size();\n        vector<vector<int>> jobs(n, vector<int> (3, 0));\n        \n        // This has been so that we could sort it on the basis of the startTime\n        // Why? -> This is becaue we need to consder all the tasks at first and the one we must start \n        // from the index which is started first and then go consecutively in forward direction, where the events\n        // too are sorted in that fashion so that we could get the first element whose startTime is more than the       EndTime of the curr index, and also it is least possible start time.       \n        for(int i=0; i<n; i++){\n            jobs[i][0] = startTime[i];\n            jobs[i][1] = endTime[i];\n            jobs[i][2] = profit[i];\n        }\n        // Simply sort(reason explained above)\n        sort(jobs.begin(), jobs.end());\n        vector<int> dp(n+1, -1);\n        // Make a recursion call\n        return f(0, jobs, n, dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4519851/simple-recursive-dp-solution/",
        "code": "class Solution {\npublic:\n    int dp[50005];\n    vector<pair<int, pair<int,int> > > P;\n    int solve(int i, vector<int> &V) {\n        if(i>=P.size()) {\n            return 0;\n        }\n        if(dp[i]!=-1) {\n            return dp[i];\n        }\n        int nextInd = lower_bound(V.begin(), V.end(), P[i].second.first) - V.begin();\n        dp[i] = max(P[i].second.second + solve(nextInd, V), solve(i+1, V));\n        return dp[i];\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        memset(dp, -1, sizeof(dp));\n        for(int i=0;i<startTime.size();i++) {\n            P.push_back({startTime[i], {endTime[i], profit[i]}});\n        } \n        sort(P.begin(), P.end());\n        vector<int>newArrayIndex;\n        for(int i=0;i<P.size();i++) {\n            newArrayIndex.push_back(P[i].first);\n        }\n        return solve(0, newArrayIndex);\n    }\n};\n\n/*\n\n*/"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4519772/100-faster-code/",
        "code": "class Solution {\n    // int solve(vector<int>& startTime, vector<int>& endTime, vector<int>& profit,int idx,vector<int>&dp){\n    //     if(idx>=startTime.size()) return 0;\n    //     if(dp[idx]!=-1) return dp[idx];\n    //     int nextJobIdx=lower_bound(startTime.begin()+idx,startTime.end(),endTime[idx])-startTime.begin();\n    //     int  inc=profit[idx]+solve(startTime,endTime,profit,nextJobIdx,dp);\n    //     int exc=solve(startTime,endTime,profit,idx+1,dp);\n    //     return dp[idx]=max(inc,exc);\n    // }\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n=startTime.size();\n        vector<pair<int,pair<int,int>>>vp;\n        for(int i=0;i<n;i++){\n            vp.push_back(make_pair(startTime[i],make_pair(endTime[i],profit[i])));\n        }\n        sort(vp.begin(),vp.end());\n        for(int i=0;i<n;i++){\n            startTime[i]=vp[i].first;\n            endTime[i]=vp[i].second.first;\n            profit[i]=vp[i].second.second;\n        }\n        vector<int>dp(n+1,0);\n        for(int idx=n-1;idx>=0;idx--){\n            int nextJobIdx=lower_bound(startTime.begin()+idx,startTime.end(),endTime[idx])-startTime.begin();\n            // if(nextJobIdx<=n)\n            int  inc=profit[idx]+dp[nextJobIdx];\n            int exc=dp[idx+1];\n            dp[idx]=max(inc,exc);\n        }\n        return dp[0];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4519037/c-dp-binary-search-detailed-explanation-with-clear-code/",
        "code": "class Solution {\npublic:\n            \n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n\n        int n = startTime.size();\n        vector<vector<int>> tmp(n);\n        for(int i = 0; i < n; ++i) {\n            tmp[i] = {startTime[i], endTime[i], profit[i]};\n        }\n\n        sort(tmp.begin(), tmp.end());\n        for(int i = 0; i < n; ++i) {\n            startTime[i] = tmp[i][0];\n            endTime[i] = tmp[i][1];\n            profit[i] = tmp[i][2];\n        }\n\n        vector<int> dp(n + 1, -1);\n        dp.back() = profit.back();\n\n        for(int i = n - 1; i >= 0; --i) {\n            int include = profit[i];\n            // get next non-overlapping range\n            // next start that <= curr end\n            auto it = lower_bound(startTime.begin(), startTime.end(), endTime[i]);\n            if(it != startTime.end()) {\n                int nxt = it - startTime.begin();\n                include += dp[nxt];\n            }\n            int exclude = dp[i + 1];\n            dp[i] = max(include, exclude);\n        }\n\n        return dp[0];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4518505/c-solution-dp-approch/",
        "code": "class Solution {\npublic:\n        int find(int i , vector<vector<int>>& job, vector<int>&startTime,int n,vector<int>& dp){\n\n         \n        if(i>=n) return 0;\n        if(dp[i]!=-1) return dp[i];\n        int index = lower_bound(startTime.begin(), startTime.end(),job[i][1])-startTime.begin();\n        int pick = job[i][2]+find(index,job,startTime,n, dp);\n        int notpick = find(i+1 ,job,startTime,n, dp);\n        return dp[i] =max(pick,notpick);\n     }\n        \n\n\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n\n        int n = startTime.size();\n        vector<vector<int>> job;\n        vector<int> dp(n,-1);\n        for(int i=0;i<n;i++)\n            job.push_back({startTime[i],endTime[i],profit[i]});\n            sort(job.begin(),job.end());\n            sort(startTime.begin(),startTime.end());\n            return find(0,job,startTime,n,dp);\n\n    }\n\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517908/easy-solution-in-c-using-sorting-dp-and-binary-search/",
        "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n    int n = startTime.size();\n    vector<vector<int>> jobs;\n    for (int i = 0; i < n; ++i) {\n        jobs.push_back({endTime[i], startTime[i], profit[i]});\n    }\n    sort(jobs.begin(), jobs.end());\n    vector<pair<int, int>> dp = {{0, 0}};\n    for (auto job:jobs) {\n        int start = job[1];\n        int end = job[0];\n        int p = job[2];\n        int prevIdx = upper_bound(dp.begin(), dp.end(), make_pair(start, INT_MAX)) - dp.begin() - 1;\n        int maxProfit = max(dp[prevIdx].second + p, dp.back().second);\n        dp.emplace_back(end, maxProfit);\n    }\n    return dp.back().second;\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517651/c-dp-99-ms-beats-99-29/",
        "code": "class Solution {\npublic:\n   int find(int i,vector<vector<int>>& job,vector<int>&startTime,int n,vector<int>& dp){\n\t\tif(i>=n) return 0;\n\t\tif(dp[i]!=-1) return dp[i];\n\t\tint index = lower_bound(startTime.begin(),startTime.end(),job[i][1])-startTime.begin();\n\t\tint pick=job[i][2]+find(index,job,startTime,n,dp);\n\t\tint notpick=find(i+1,job,startTime,n,dp);\n\t\treturn dp[i]=max(pick,notpick);\n\t}\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        //low1 = std::lower_bound(v.begin(), v.end(), 30); \n        int n=startTime.size();\n\t\tvector<vector<int>> job;\n\t\tvector<int> dp(n,-1);\n\t\tfor(int i=0;i<n;i++) \n            job.push_back({startTime[i],endTime[i],profit[i]});  \n\t\tsort(job.begin(),job.end());\n\t\tsort(startTime.begin(),startTime.end());\n\t\treturn find(0,job,startTime,n,dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517616/very-easy-method-of-dp-and-binary-search/",
        "code": "\nclass Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<vector<int>> jobs(n);\n        for (int i = 0; i < n; ++i) {\n            jobs[i] = {endTime[i], startTime[i], profit[i]};\n        }\n        sort(jobs.begin(), jobs.end());\n\n        vector<int> dp(n);\n        dp[0] = jobs[0][2];\n\n        for (int i = 1; i < n; ++i) {\n            int l = 0, r = i;\n            while (l < r) {\n                int mid = l + (r - l) / 2;\n                if (jobs[mid][0] <= jobs[i][1]) {\n                    l = mid + 1;\n                } else {\n                    r = mid;\n                }\n            }\n            int currProfit = jobs[i][2];\n            if (l > 0) {\n                currProfit += dp[l - 1];\n            }\n            dp[i] = max(dp[i - 1], currProfit);\n        }\n        return dp[n - 1];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517393/c-simple-solution-using-binary-search/",
        "code": "typedef struct {\n    int start;\n    int end;\n    int profit;\n} Tuple;\n\nint compare (Tuple *x, Tuple *y) {\n\t/* for ascending, return *x - *y\n\t   for descending return *y - *x */\n    if (x->end == y->end) {\n        return y->start - x->start;\n    }\n    return x->end - y->end;\n}\n\nvoid insertionSort(Tuple **a, int lo, int hi) {\n    int i, j;\n    Tuple *t;\n    for (i = lo+1; i <= hi; ++i) {\n        t = a[i];\n        j = i-1;\n        while (j >= lo && compare(a[j], t) > 0) {\n           a[j+1] = a[j];\n           --j;\n        }\n        a[++j] = t;\n    }\n}\n\nvoid quickSort(Tuple **a, int lo, int hi) {\n    int pi, i, j;\n    Tuple *pv, *t;\n    if (lo >= hi - 10) {\n        insertionSort(a, lo, hi);\n        return;\n    }\n    pi = (lo + hi) / 2;\n    pv = a[pi];\n    a[pi] = a[hi];\n    a[hi] = pv;\n    i = lo - 1;\n    j = hi;\n    do {\n        do { i++; } while (compare(a[i], pv) < 0);\n        do { j--; } while (compare(a[j], pv) > 0 && j > lo);\n        if (i < j) {\n            t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    } while (i < j);\n    a[hi] = a[i];\n    a[i] = pv;\n    quickSort(a, lo, i-1); \n    quickSort(a, i+1, hi);\n}\n\nint jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize) {\n    int i, lo, mid, hi, n = profitSize;\n    Tuple pool[n], *job[n];\n    for (i = 0; i < n; ++i) {\n        job[i] = &pool[i];\n        pool[i].start = startTime[i];\n        pool[i].end = endTime[i];\n        pool[i].profit = profit[i];\n    }\n    quickSort(job, 0, n-1);\n    for (i = 1; i < n; ++i) {\n        lo = -1, hi = i-1;\n        while (lo < hi) {\n            mid = (lo + hi + 1) >> 1;\n            if (job[i]->start < job[mid]->end) {\n                hi = mid - 1;\n            } else {\n                lo = mid;\n            }\n        }\n        if (lo >= 0) {\n            job[i]->profit += job[lo]->profit;\n        }\n        if (job[i]->profit < job[i-1]->profit) {\n            job[i] = job[i-1];\n        }\n    }\n    return job[n-1]->profit;\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517217/tabulation-stl-lower-bound-c/",
        "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n    int n = startTime.size();\n    vector<vector<int>> inp(n, vector<int>(3));\n\n    for (int i = 0; i < n; i++) {\n        inp[i][0] = startTime[i];\n        inp[i][1] = endTime[i];\n        inp[i][2] = profit[i];\n    }\n\n    sort(inp.begin(), inp.end(), [](const vector<int>& row1, const vector<int>& row2) -> bool {\n        return row1[0] < row2[0];\n    });\n\n    vector<int> table(n + 1, 0);\n\n    for (int i = n - 1; i >= 0; i--) {\n        auto it = lower_bound(inp.begin() + i + 1, inp.end(), inp[i][1], [](const vector<int>& row, int val) {\n            return row[0] < val;\n        });\n\n        int notTake = table[i + 1];\n        int take = (it != inp.end()) ? table[distance(inp.begin(), it)] : 0;\n\n        table[i] = max(inp[i][2] + take, notTake);\n    }\n\n    return table[0];\n}\n\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516638/push-dp-solution/",
        "code": "#define ll long long\nclass Solution {\npublic:\n    int jobScheduling(vector<int>& s, vector<int>& e, vector<int>& profit) {\n        vector<pair<pair<int,int>,int>> range;\n        int n= s.size();\n        for(int i=0;i<n;i++){\n            range.push_back({{s[i],e[i]},profit[i]});\n        }\n        auto comp = [&]( const pair<pair<int,int>,int>& a,const pair<pair<int,int>,int>& b ){\n            return a.first.first < b.first.first ;\n        };\n        sort(range.begin(),range.end(), comp);\n        vector<ll> dp(n+1);\n        auto lowerBound = [&](const int x , int i){\n            int low = i+1 , high = n-1;\n            while(low<=high){\n                int mid = (low+high)/2;\n                if( range[mid].first.first >= x) high = mid-1;\n                else low = mid+1;\n            }\n            return low ;\n        };\n        for(int i=0;i<n;i++){\n            int ind = lowerBound(range[i].first.second, i);\n            if(ind<=n) dp[ind] = max(dp[ind],dp[i]+range[i].second);\n            dp[i+1]= max(dp[i+1],dp[i]);\n        }\n        return dp[n];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515712/simple-nottake-take-memoization/",
        "code": "class Solution {\npublic:\n    int solve(vector<vector<int>>&jobs,vector<int>& startTime,int index,vector<int>&dp){\n        if(index==startTime.size()){\n            return 0;\n        }\n        if(dp[index]!=-1)\n            return dp[index];\n        int nextIndex=lower_bound(startTime.begin(),startTime.end(),jobs[index][1])-startTime.begin();\n        //notTake\n        int a=solve(jobs,startTime,index+1,dp);\n        //take\n        int b=jobs[index][2]+solve(jobs,startTime,nextIndex,dp);\n        return dp[index]=max(a,b);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        vector<vector<int>>jobs;\n        int n=startTime.size();\n        vector<int>dp(n+1,-1);\n        for(int i=0;i<startTime.size();i++){\n            jobs.push_back({startTime[i],endTime[i],profit[i]});\n        }\n        sort(jobs.begin(),jobs.end());\n        for(int i=0;i<jobs.size();i++){\n            startTime[i]=jobs[i][0];\n        }\n        return solve(jobs,startTime,0,dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515283/c-solution-using-lower-bound/",
        "code": "class Solution {\npublic:\n    int dp[50001];\n\n    int getMaxProfit(int index, vector<vector<int>>&arr, int targetColumn){\n        if(index >= arr.size())\n            return 0;\n        \n        if(dp[index]!=-1)\n            return dp[index];\n\n        int res = 0;\n\n        // to find next index\n        auto lowerBoundIter = lower_bound(arr.begin(), arr.end(), arr[index][1], [targetColumn](const vector<int>& a, int value) {\n            return a[targetColumn] < value;\n        });\n\n        int rowIndex = distance(arr.begin(), lowerBoundIter);\n\n        res = max(arr[index][2] + getMaxProfit(rowIndex, arr, targetColumn), getMaxProfit(index+1, arr, targetColumn));\n\n        return dp[index] = res;\n    }\n\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = profit.size();\n        vector<vector<int>>arr(n);\n\n        for(int i=0;i<n;i++){\n            arr[i] = {startTime[i], endTime[i], profit[i]};\n        }\n\n        sort(arr.begin(), arr.end());\n        memset(dp, -1, sizeof(dp));\n\n        int res = 0;\n\n        for(int i=n-1;i>=0;i--){\n            int val = getMaxProfit(i, arr, 0);\n            res = max(res, val);\n        }\n\n        return res;\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514945/easy-c/",
        "code": "class Solution {\npublic:\n    vector<int> dp;\n    int solve(vector<pair<int, pair<int, int>>> &v, vector<int>& s, int i, int prev){\n        if(i>=v.size())return 0;\n        if(dp[i]!=-1)return dp[i];\n        int t=0, nt=0;\n        int ind=lower_bound(s.begin(), s.end(), v[i].second.first)-s.begin();\n        t=v[i].second.second+solve(v, s, ind, prev);\n        nt=solve(v, s, i+1, prev);\n        return dp[i]=max(t, nt);\n    }\n\n    int jobScheduling(vector<int>& s, vector<int>& e, vector<int>& p) {\n        vector<pair<int, pair<int, int>>> v;\n        int n=s.size();\n        dp.resize(n,  -1);\n        for(int i=0; i<n; i++){\n            v.push_back({s[i], {e[i], p[i]}});\n        }\n        sort(s.begin(), s.end());\n        sort(v.begin(), v.end());\n        return solve(v, s, 0, -1);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514864/c/",
        "code": "struct list{\n    int start;\n    int end;\n    int point;\n};\n\nint max (int a, int b){\n    return a > b ? a : b;\n}\n\nint next (int now, int finishtime, struct list* book, int startTimeSize){\n    for (int i = now+1 ; i < startTimeSize ; i++){\n        if (finishtime <= book[i].start){\n            return i;\n        }\n    }\n    return startTimeSize;\n}\n\nint comp(const void* a, const void* b){\n    return *(int*)a - *(int*)b;\n}\n\nint jobScheduling(int* startTime, int startTimeSize, int* endTime, int endTimeSize, int* profit, int profitSize){\n    int start[50001];\n    start[startTimeSize] = 0;\n    struct list* book = malloc(sizeof(struct list)*startTimeSize);\n    for (int i = 0 ; i < startTimeSize ; i++){\n        book[i].start = startTime[i];\n        book[i].end = endTime[i];\n        book[i].point = profit[i];\n    } \n    qsort(book, startTimeSize, sizeof(struct list), comp);\n    for (int i = startTimeSize-1 ; i >= 0 ; i--){\n        start[i] = max(book[i].point + start[next(i, book[i].end, book, startTimeSize)], start[i+1]);\n    }\n    free(book); \n    return start[0];\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516818/c-dp-binary-search-very-easy-approach/",
        "code": "class Solution {\npublic:\n    int f(int i, vector<vector<int>>&v, vector<int>&dp){\n        if(i>=v.size())return 0;\n        if(dp[i]!=-1)return dp[i];\n        int tk=0, ntk=0;\n        int st=i, en=v.size()-1;\n        while(st<=en){\n            int mid=st+(en-st)/2;\n            if(v[mid][0]>=v[i][1])en=mid-1;\n            else st=mid+1;\n        }\n        tk=v[i][2]+f(st, v, dp);\n        ntk=f(i+1, v, dp);\n        return dp[i]=max(tk, ntk);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        vector<vector<int>>v;\n        for(auto i=0; i<startTime.size(); i++){\n            v.push_back({startTime[i], endTime[i], profit[i]});\n        }\n        sort(begin(v), end(v));\n        vector<int>dp(startTime.size(), -1);\n        return f(0, v, dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515709/easy-binary-search-on-dp-c/",
        "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<pair<pair<int, int>, int>> job;\n        pair<int, int> dp[n+1];\n        job.push_back({{0, 0}, 0});\n        for(int i = 0; i < n; i++){\n            job.push_back({{endTime[i], startTime[i]}, profit[i]});\n        }\n        sort(job.begin(), job.end());\n        dp[0] = {0, 0};\n        for(int i = 1; i <= n; i++){\n            if(i > 0) dp[i] = dp[i-1];\n            int l = 0, r = i-1, mid;\n            while(l < r){\n                mid = (l+r+1)/2;\n                if(dp[mid].second <= job[i].first.second) l = mid;\n                else r = mid-1;\n            }\n            if(dp[i].first < dp[l].first + job[i].second){\n                dp[i] = {dp[l].first + job[i].second, job[i].first.first};\n            }\n        }\n        return dp[n].first;\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517645/easy-to-understand-solution-using-dp/",
        "code": "class Solution {\npublic:\n    int solve(int index,int end,vector<vector<int>>&map,vector<int>&startTime,vector<int>&dp){\n        if(index>=end){\n            return 0;\n        }\n        if(dp[index] != -1){\n            return dp[index];\n        }\n        int newindex = lower_bound(startTime.begin(),startTime.end(),map[index][1])-startTime.begin();\n        int pick = map[index][2]+solve(newindex,end,map,startTime,dp);\n        int notpick = solve(index+1,end,map,startTime,dp);\n        return dp[index] = max(pick,notpick);\n    }\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<vector<int>> map(n,vector<int>(3,0));\n        vector<int> dp(n,-1);\n        for(int i = 0; i<n ; i++){\n            map[i][0] = startTime[i];\n            map[i][1] = endTime[i];\n            map[i][2] = profit[i];\n        }\n        sort(map.begin(),map.end());\n        sort(startTime.begin(),startTime.end());\n\n        return solve(0,n,map,startTime,dp);\n\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/2799295/c-dp-binary-search-easy-clean-solution/",
        "code": "class Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<tuple<int, int, int>> v(n);\n        for (int i = 0; i < n; i++) {\n            v[i] = make_tuple(endTime[i], startTime[i], profit[i]);\n        }\n        sort(v.begin(), v.end());\n        vector<int> dp(n);\n        for (int i = 0; i < n; i++) {\n            dp[i] = get<2>(v[i]);\n            if (i > 0) {\n                dp[i] = max(dp[i], dp[i - 1]);\n            }\n            {\n                int l = 0, r = i - 1, at = -1;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    if (get<0>(v[mid]) <= get<1>(v[i])) {\n                        l = mid + 1;\n                        at = mid;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n                if (at != -1) {\n                    dp[i] = max(dp[i], dp[at] + get<2>(v[i]));\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4484858/easiest-detailed-solution-with-intuition-about-each-step-dp-sorting-binary-search/",
        "code": "int binarysearcher(vector <vector <int> > &v,int key,int s,int e){\n    int temp=v.size();\n    while(s<=e){\n        int mid=(s+e)/2;\n        if (v[mid][0]<key){\n            s=mid+1;\n        }\n        else{\n            temp=mid;\n            e=mid-1;\n        }\n    }\n    return temp;\n}\n\nint helper(int i,vector <vector <int> > &v,vector <int> &dp){\n    if (i>=v.size()){\n        return 0;\n    }\n    if (dp[i]!=-1){\n        return dp[i];\n    }\n    //exclude\n    int excl=helper(i+1,v,dp);\n    //include\n    int incl=v[i][2];\n    int index=binarysearcher(v,v[i][1],i+1,v.size()-1);//just equal or greater \n    incl+=helper(index,v,dp);\n    dp[i]=max(incl,excl);\n    return dp[i];\n}\nbool comparator(vector <int> &a,vector <int> &b){\n    return a[0]<b[0];\n}\n\nclass Solution {\npublic:\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        //sort jobs acc to startTime\n        vector <vector <int> > v(startTime.size());\n        for(int i=0;i<startTime.size();i++){\n            vector <int> tempo={startTime[i],endTime[i],profit[i]};\n            v[i]=tempo;\n        }\n        sort(v.begin(),v.end(),comparator);\n        vector <int> dp(startTime.size(),-1);\n        return helper(0,v,dp);\n    }\n};"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517121/simple-cpp-solution-o-n-logn-tc-o-n-sc/",
        "code": "class Solution {\n    vector<int> dp;\n    int dfs(int idx, vector<vector<int>>& se, vector<int>& s){\n        if(idx == se.size()){\n            return 0;\n        }\n        if(dp[idx] != -1) return dp[idx];\n        int nextIdx = lower_bound(s.begin(), s.end(), se[idx][1]) - s.begin();\n        return dp[idx] = max(\n            se[idx][2] + dfs(nextIdx, se, s),\n            dfs(idx+1, se, s)\n        );\n    }  \npublic: \n    int jobScheduling(vector<int>& s, vector<int>& e, vector<int>& p) {\n        vector<vector<int>> se;\n        dp.resize(s.size(), -1);\n        for(int i = 0; i < s.size(); i++)\n            se.push_back({s[i], e[i], p[i]});\n        sort(se.begin(), se.end());\n        sort(s.begin(), s.end());\n        return dfs(0, se, s);\n    }\n};\n"
      }
    ]
  },
  {
    "language": "kotlin",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515901/kotlin-compact-solution/",
        "code": "class Solution {\n    fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int = TreeMap<Int, Int>().apply { \n        put(0, 0) \n        endTime.indices.sortedBy { endTime[it] }.forEach { i ->\n            (profit[i] + floorEntry(startTime[i]).value).let {\n                if(it > lastEntry().value) this[endTime[i]] = it\n            }\n        }\n    }.lastEntry().value\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517608/kotlin-treemap-solution/",
        "code": "class Solution {\n    fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {\n        var joblist = mutableListOf<Triple<Int, Int, Int>>()\n        val n = startTime.size\n\n        for (i in 0 until n) {\n            joblist.add(Triple(startTime[i], endTime[i], profit[i]))\n        }\n\n        joblist.sortWith(compareBy({ it.second }, { it.first }, { it.third }))\n\n        val tree = TreeMap<Int, Int>()\n        tree.put(0, 0)\n\n        var result = 0\n        for (job in joblist) {\n            val lk = tree.floorKey(job.first)\n            val pre = tree.getOrDefault(lk, 0)\n            val expt = pre + job.third\n\n            val uk = tree.floorKey(job.second)\n            val post = tree.getOrDefault(uk, 0)\n\n            if (post < expt) {\n                tree.put(job.second, expt)\n                result = maxOf(result, expt)\n            }\n        }\n\n        return result\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516146/kotlin-dp/",
        "code": "\n  fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {\n    val inds = startTime.indices.sortedBy { startTime[it] }\n    val dp = IntArray(inds.size + 1)\n    for (i in inds.indices.reversed()) {\n      var lo = i + 1\n      var hi = inds.lastIndex\n      while (lo <= hi) {\n        val m = lo + (hi - lo) / 2\n        if (endTime[inds[i]] > startTime[inds[m]]) lo = m + 1 else hi = m - 1\n      }\n      dp[i] = max(dp[i + 1], profit[inds[i]] + dp[lo])\n    }\n    return dp[0]\n  }\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4520407/typescript-solution-100-runtime-for-now-at-least-using-dp-bs-and-a-custom-array-for-funsies/",
        "code": "interface Job {\n  start: number\n  end: number\n  profit: number\n}\n\nclass JobArray extends Array<Job> {\n  public maximumProfit (): number {\n    const scores = new Array(this.length + 1)\n    scores[this.length] = 0\n    for (let i = this.length - 1; i >= 0; i--) {\n      scores[i] = Math.max(this[i].profit + scores[this.findNextJobIndex(i)], scores[i + 1])\n    }\n    return scores[0]\n  }\n\n  public findNextJobIndex (low: number): number { \n    const target = this[low].end\n    let high = this.length\n    while (low < high) {\n      const mid = (low + high) >>> 1\n      if (this[mid].start < target) low = mid + 1\n      else high = mid\n    }\n    return high\n  }\n\n  public sortBySchedules (): JobArray {\n    return this.sort((a, b) => a.start - b.start || a.end - b.end)\n  }\n\n  public static fromInputs (starts: number[], ends: number[], profits: number[]): JobArray {\n    const output = new JobArray(starts.length)\n    for (let i = 0, bound = starts.length; i < bound; i++) {\n      output[i] = { start: starts[i], end: ends[i], profit: profits[i] }\n    }\n    return output\n  }\n}\n\nconst jobScheduling = (starts: number[], ends: number[], profits: number[]): number => {\n  return JobArray.fromInputs(starts, ends, profits).sortBySchedules().maximumProfit()\n}"
      }
    ]
  },
  {
    "language": "python",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514876/dp-approach/",
        "code": "from typing import List\nimport bisect\n\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(startTime, endTime, profit), key=lambda x: x[1])\n        sorted_end_times = [x[1] for x in jobs]\n        n = len(jobs)\n        \n        dp = [0] * n\n        dp[0] = jobs[0][2]\n\n        for i in range(1, n):\n            current_start, _, current_profit = jobs[i]\n            # Find the latest job that finishes before the current job starts\n            j = bisect.bisect_right(sorted_end_times, current_start) - 1\n            if j >= 0:\n                current_profit += dp[j]\n                \n            dp[i] = max(current_profit, dp[i - 1])\n\n        return dp[-1]"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516080/simple-optimal-99-dp-no-heap-or-binary-search-needed/",
        "code": "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        jobs = sorted([(startTime[i], endTime[i], profit[i]) for i in range(n)])\n\n        nextPossJob = [n]*n\n        # startorder_i will iterate through jobs in order of startTime (how jobs is ordered)\n        # endorder_i will iterate through jobs in order of endTime\n        startorder_i = 0\n        for endorder_i in sorted(range(n), key=lambda x:jobs[x][1]):\n            while startorder_i < n and jobs[endorder_i][1] > jobs[startorder_i][0]:\n                startorder_i += 1\n            if startorder_i == n:\n                break\n            nextPossJob[endorder_i] = startorder_i\n\n        dp = [0]*(n+1)\n        for i in range(n-1, -1, -1):\n            # Two possibilities: use the current job at i or skip to next job\n            dp[i] = max(jobs[i][2] + dp[nextPossJob[i]], dp[i+1])\n        return dp[0]"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514755/python-o-nlogn-beats-100/",
        "code": "class Solution: \n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        q = [0]\n        P = [0,0]\n        for e,s,p in sorted(zip(endTime, startTime, profit)):\n            pp = P[bisect_right(q, s)] + p\n            if pp > P[-1]:\n                q.append(e)\n                P.append(pp)\n        return P[-1]        "
      }
    ]
  },
  {
    "language": "java☕",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515493/o-n-logn-java-python-javascript-dynamic-programming-binary-search/",
        "code": "class Solution {\n    private static class Job{\n        int start, end, profit;\n\n        // Constructor\n        Job(int start, int end, int profit){\n            this.start = start;\n            this.end = end;\n            this.profit = profit;\n        }\n    }\n\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int jobCount = profit.length; // Total number of Jobs\n        Job[] jobs = new Job[jobCount];\n\n        for(int index=0; index<jobCount; index++)\n            jobs[index] = new Job(startTime[index], endTime[index], profit[index]);\n\n        // Sort the array on basis on EndTime of the Job\n        Arrays.sort(jobs, (a,b) -> a.end - b.end);\n        int[] dp = new int[jobCount+1];\n\n        for(int index=0; index<jobCount; index++){\n            int start = jobs[index].start;\n            int end = jobs[index].end;\n            int profits = jobs[index].profit;\n\n            int nonConflictIndex = upperBound(jobs, index, start);\n            dp[index+1] = Math.max(dp[index], dp[nonConflictIndex] + profits);\n        }\n\n        return dp[jobCount];\n    }\n\n    // Binary Search\n    private int upperBound(Job[] jobs, int endIndex, int targetIndex){\n        int low = 0;\n        int high = endIndex;\n\n        while(low < high){\n            int mid = (low + high) / 2;\n            if(jobs[mid].end <= targetIndex)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n\n        return low;\n    }\n}"
      }
    ]
  },
  {
    "language": "swift",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4518942/topic/",
        "code": "class Solution {\n    func jobScheduling(_ startTime: [Int], _ endTime: [Int], _ profit: [Int]) -> Int {\n        let jobs = zip(startTime, zip(endTime, profit)).sorted { $0.1.0 < $1.1.0 }\n        var dp: [(time: Int, profit: Int)] = [(0, 0)]\n\n        for job in jobs {\n            let currentProfit = dp.last!.profit + job.1.1\n            if job.0 >= dp.last!.time {\n                dp.append((job.1.0, currentProfit))\n            } else {\n                var l = 0, r = dp.count - 1\n                while l < r {\n                    let m = (l + r) / 2\n                    if dp[m].time <= job.0 { l = m + 1 }\n                    else { r = m }\n                }\n                let lastProfit = dp[l-1].profit + job.1.1\n                if lastProfit > dp.last!.profit {\n                    dp.append((job.1.0, lastProfit))\n                }\n            }\n        }\n\n        return dp.last!.profit\n    }\n}"
      }
    ]
  },
  {
    "language": "go",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517854/simple-dp-solution-binary-search/",
        "code": "func jobScheduling(startTime []int, endTime []int, profit []int) int {\n    dp := make([]int, len(startTime)+1)\n    summary := make([][3]int, len(startTime))\n    for i := 0; i < len(startTime); i++ {\n        summary[i][0], summary[i][1], summary[i][2] = startTime[i], endTime[i], profit[i]\n    }\n    sort.Slice(summary, func(i, j int)bool {return summary[i][0] < summary[j][0]})\n    sort.Ints(startTime)\n    \n    for i := len(startTime)-1; i >= 0; i-- {\n        dp[i] = summary[i][2]\n        index := sort.SearchInts(startTime, summary[i][1])\n        if index < len(startTime) {dp[i] += dp[index]}\n        if dp[i] < dp[i+1] {dp[i] = dp[i+1]}\n    }\n    return dp[0]\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4514828/java-clean-code-daily-challenges/",
        "code": "class Solution {\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int len = startTime.length;\n        int[][] dp = new int[len][3];\n        for(int i=0; i<len; i++){\n            dp[i] = new int[]{startTime[i], endTime[i], profit[i]};\n        }\n\n        Arrays.sort(dp, (a,b)->a[1]-b[1]);\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(0, 0);\n        for(var i:dp){\n            int cur = map.floorEntry(i[0]).getValue() + i[2];\n            if(cur > map.lastEntry().getValue()){\n                map.put(i[1], cur);\n            }\n        }\n\n        return map.lastEntry().getValue();\n    }\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4520216/rust-go-n-log-n-solution-bit-and-sorting-with-explanation/",
        "code": "import \"sort\"\n\ntype BIT struct {\n  bit map[int]int\n  max int\n}\n\nfunc BIT_init(max_val int) BIT {\n  return BIT{\n    bit: map[int]int{},\n    max: max_val,\n  }\n}\n\nfunc (self *BIT) update_max(p, v int) {\n  p++\n  for p < self.max {\n    if v > self.bit[p] {\n      self.bit[p] = v\n    }\n    p += p & (-p)\n  }\n}\n\nfunc (self *BIT) prefix_max(p int) int {\n  res, p := 0, p + 1\n  \n  for p != 0 {\n    if self.bit[p] > res {\n      res = self.bit[p]\n    }\n    p -= p & (-p)\n  }\n  return res\n}\n\nfunc get_data(ts_start []int, ts_end []int, profit []int) ([][3]int, int) {\n  n, max_val := len(ts_start), 0\n  data := make([][3]int, n)\n  \n  for i := 0; i < n; i++ {\n    data[i] = [3]int{ts_start[i], ts_end[i], profit[i]}\n    if ts_end[i] > max_val {\n      max_val = ts_end[i]\n    } \n  }\n  \n  sort.Slice(data, func(i, j int) bool { return data[i][1] < data[j][1]})\n  return data, max_val + 2\n}\n\nfunc jobScheduling(ts_start []int, ts_end []int, profit []int) int {\n  data, max_val := get_data(ts_start, ts_end, profit)\n  \n  bit := BIT_init(max_val)\n  for _, v := range data {\n    bit.update_max(v[1], bit.prefix_max(v[0]) + v[2])\n  }\n  \n  return bit.prefix_max(max_val - 2)\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515004/the-dynamic-programming-and-greedy-method-combination/",
        "code": "// Job struct represents a job with startTime, endTime, and profit\ntype Job struct {\n\tstartTime, endTime, profit int\n}\n\n// ByEndTime implements sort.Interface based on the endTime field\ntype ByEndTime []Job\n\nfunc (a ByEndTime) Len() int           { return len(a) }\nfunc (a ByEndTime) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a ByEndTime) Less(i, j int) bool { return a[i].endTime < a[j].endTime }\n\n// binarySearch finds the latest job that doesn't overlap with the current job\nfunc binarySearch(jobs []Job, index int) int {\n\tlow, high := 0, index-1\n\tfor low <= high {\n\t\tmid := (low + high) / 2\n\t\tif jobs[mid].endTime <= jobs[index].startTime {\n\t\t\tif jobs[mid+1].endTime <= jobs[index].startTime {\n\t\t\t\tlow = mid + 1\n\t\t\t} else {\n\t\t\t\treturn mid\n\t\t\t}\n\t\t} else {\n\t\t\thigh = mid - 1\n\t\t}\n\t}\n\treturn -1\n}\n\n// maxProfitJobSchedulingGreedy calculates the maximum profit for non-overlapping jobs using greedy algorithm\nfunc jobScheduling(startTime []int, endTime []int, profit []int) int {\n\tn := len(startTime)\n\tjobs := make([]Job, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tjobs[i] = Job{startTime[i], endTime[i], profit[i]}\n\t}\n\n\t// Sort jobs based on endTime\n\tsort.Sort(ByEndTime(jobs))\n\n\t// dp[i] stores the maximum profit till job i\n\tdp := make([]int, n)\n\tdp[0] = jobs[0].profit\n\n\tfor i := 1; i < n; i++ {\n\t\t// Calculate profit including the current job\n\t\tincluding := jobs[i].profit\n\t\tl := binarySearch(jobs, i)\n\t\tif l != -1 {\n\t\t\tincluding += dp[l]\n\t\t}\n\n\t\t// Calculate profit excluding the current job\n\t\texcluding := dp[i-1]\n\n\t\t// Store the maximum profit till job i\n\t\tdp[i] = max(including, excluding)\n\t}\n\n\treturn dp[n-1]\n}\n\n// max returns the maximum of two integers\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516136/daily-question-maximum-profit-in-job-scheduling-golang/",
        "code": "func jobScheduling(startTime []int, endTime []int, profit []int) int {\n    end2Detail := make(map[int][][]int)\n    minEnd, maxEnd := 1000000001, -1\n    for i:=0; i<len(startTime); i++ {\n        minEnd=min(minEnd, endTime[i])\n        maxEnd=max(maxEnd, endTime[i])\n\n        end2Detail[endTime[i]]=append(end2Detail[endTime[i]], []int{startTime[i], profit[i]})\n    }\n\n    sort.Ints(endTime)\n    dp := make([][]int, 0) //[[endTime, maxProfit], [endTime, maxProfit], [endTime, maxProfit]..]\n    maxTillNow:=-1\n    for _, e := range endTime {\n        tempDp:=[]int{e, 0}\n        for _, v := range end2Detail[e] {\n            tempDp[1]=max(tempDp[1], v[1]+maxTill(dp, v[0]))\n        }\n        tempDp[1]=max(tempDp[1], maxTillNow)\n        maxTillNow=tempDp[1]\n        dp=append(dp, tempDp)\n\n    }\n\n    return maxTillNow\n}\n\nfunc maxTill(dp [][]int, start int) int {\n    if len(dp)==0 {\n        return 0\n    }\n    \n    // return profit for endTime just less than provided startTime\n    l, r:=0, len(dp)-1\n    res:=0\n    for l<=r {\n        m:=(l+r)/2\n        if dp[m][0] == start {\n            res=dp[m][1]\n            break\n        }\n        if dp[m][0] < start {\n            res=dp[m][1]\n            l=m+1\n        } else {\n            r=m-1\n        }\n    }\n    return res\n}"
      }
    ]
  },
  {
    "language": "ruby",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516213/ruby-dp-fastest-atm/",
        "code": "class Numeric\n    def max(v) = (self < v ? v : self)\nend\n\ndef job_scheduling(start_time, end_time, profit)\n    se    = end_time.sort\n    end_time.each_index.to_a.sort_by! {|i| \n        end_time[i] \n    }.each_with_index.each_with_object(Array.new(end_time.size.succ, 0)) {|(idx, i), dp|\n        dp[i+1] = dp[i].max(profit[idx] + dp[se.bsearch_index {|w| w > start_time[idx]} || -1])\n    }.last\nend\n"
      },
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4515410/recursion-memorization-python-with-explanation/",
        "code": "class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        tbl = []\n        for x, y, z in zip(startTime, endTime, profit):\n            # we need to sort first by endTime, then by startTime\n            # so we put endTime first, then it is automatically\n            # the first sorting key\n            tbl.append([y, x, z])\n        \n        # sort first by endTime, then by startTime\n        tbl.sort()\n        # we need a sorted list of endTime to find next job to deal with\n        endTime.sort() \n        # print(tbl)\n\n\n        # input: idx - index of job in the sorted tbl \n        # output: maxium profit from index 0 to index idx \n        @cache\n        def dp(idx):\n            if idx < 0:\n                # in this case, all jobs were already considered\n                # no more profit, so we return 0\n                return 0 \n            \n            # we do not choose job No.idx, \n            # then just consider the previous job\n            # ans1 is the profit we get if current job is not added\n            ans1 = dp(idx-1)\n\n            # print(tbl[idx][1])\n            # we choose job No.idx \n            # calculate which job should be considered next \n            # nxt is the index of the next job to be considered \n            nxt = bisect_left(endTime, tbl[idx][1])\n            if tbl[nxt][0] > tbl[idx][1]:\n                nxt -= 1\n            elif tbl[nxt][0] == tbl[idx][1]:\n                nxt = bisect_right(endTime, tbl[idx][1]) - 1\n            # print(nxt, tbl[nxt][0],tbl[idx][1])\n            # print(nxt)\n            \n            # ans2 is the profit we get if current job is added\n            ans2 = dp(nxt) + tbl[idx][2]\n            # print(\"idx: \", idx, ans1, ans2)\n\n            # compare and decide the bigger profit \n            return max(ans1, ans2)\n        \n        return dp(len(tbl)-1)\n"
      }
    ]
  },
  {
    "language": "sql",
    "data": [
      {
        "url": "https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4517924/dp/",
        "code": "from typing import List\nimport bisect\n\nclass Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        jobs = sorted(zip(endTime, startTime, profit))\n        dp = [(0, 0)]  # (endTime, profit)\n\n        for end, start, profit in jobs:\n            # Find the last job that does not conflict\n            i = bisect.bisect_right(dp, (start, float('inf'))) - 1\n            if dp[i][1] + profit > dp[-1][1]:\n                dp.append((end, dp[i][1] + profit))\n\n        return dp[-1][1]"
      }
    ]
  }
]